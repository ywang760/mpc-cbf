//
// Created by lishuo on 8/22/24.
//

#ifndef MPC_PIECEWISEBEZIERMPCQPGENERATOR_H
#define MPC_PIECEWISEBEZIERMPCQPGENERATOR_H

#include <mpc/optimization/PiecewiseBezierMPCQPOperations.h>
#include <splines/curves/SingleParameterPiecewiseCurve.h>

namespace mpc {

    template <typename T, unsigned int DIM>
    class PiecewiseBezierMPCQPGenerator {
    public:
        using PiecewiseBezierMPCQPOperations = mpc::PiecewiseBezierMPCQPOperations<T, DIM>;
        using PieceIndexAndParameter = typename mpc::PiecewiseBezierMPCQPOperations<T, DIM>::PieceIndexAndParameter;
        using BezierQPOperations = typename mpc::PiecewiseBezierMPCQPOperations<T, DIM>::BezierQPOperations;
        using SingleParameterPiecewiseCurve = splines::SingleParameterPiecewiseCurve<T, DIM>;
        using SingleParameterCurve = splines::SingleParameterCurve<T, DIM>;
        using CostAddition = typename mpc::PiecewiseBezierMPCQPOperations<T, DIM>::CostAddition;
        using LinearConstraint = typename mpc::PiecewiseBezierMPCQPOperations<T, DIM>::LinearConstraint;
        using State = model::State<T, DIM>;
        using VectorDIM = math::VectorDIM<T, DIM>;
        using Vector = math::Vector<T>;
        using AlignedBox = math::AlignedBox<T, DIM>;
        using Hyperplane = math::Hyperplane<T, DIM>;

        void addPiecewise(std::unique_ptr<PiecewiseBezierMPCQPOperations> &&piecewise_operations_ptr);
        size_t numPieces() const;
        const std::unique_ptr<PiecewiseBezierMPCQPOperations> &piecewise_operations_ptr() const;

        // return a reference to the problem instance generated by this generator
        qpcpp::Problem<T>& problem();

        // generates the piecewise curve from the solution to the problem(). it is
        // assumed that variables of the problem() instance is filled by a solver
        // before a call to this function
        SingleParameterPiecewiseCurve generateCurveFromSolution() const;

        Vector getVariablesValue() const;

        // mpc cost, for piecewise
        void addPositionErrorPenaltyCost(const State &current_state, const Vector &ref_positions);
        void addEvalPositionErrorPenaltyCost(const Vector &ref_positions);
        void addControlEffortPenaltyCost();
        // add
        // lambda*\int_{0}^{max_parameter}||df^{derivative_degree}(t)/dt^{derivative_degree}||^2dt
        // cost to the generated problem
        void addIntegratedSquaredDerivativeCost(uint64_t derivative_degree,
                                                T lambda);

        // piecewise constraints
        void addEvalBoundConstraints(uint64_t derivative_degree,
                                     const VectorDIM& LB,
                                     const VectorDIM& UB);


        // piece cost

        // constraints
        // add df^{derivative_degree}/dt^{derivative_degree}(paramter) = target
        // constraint to the generated qp
        void addEvalConstraint(T parameter, uint64_t derivative_degree,
                               const VectorDIM& target);

        // adds a continuity constraint between pieces with indices piece_idx and
        // piece_idx + 1 on the derivative_degree^th derivative. return status is
        // not ok if piece_idx or piece_idx+1 is out of range
        void addContinuityConstraint(std::size_t piece_idx,
                                     uint64_t derivative_degree);

        // constraints the given piece to be in the negative side of the given
        // hyperplane
        void addHyperplaneConstraintForPiece(std::size_t piece_idx,
                                             const Hyperplane& hyperplane,
                                             T epsilon = 1e-8);

        // constraint the derivative of the curve within a bounding box
        void addBoundingBoxConstraintAll(const AlignedBox& bounding_box,
                                         uint64_t derivative_degree);

        // constraint the trajectory at the given parameter to be in the negative
        // side of the given hyperplane
        void addHyperplaneConstraintAt(T parameter,
                                       const Hyperplane& hyperplane,
                                       T epsilon = 1e-8);

        // adds given cost_addition for piecewise to the generated qp.
        void addCostAdditionForPiecewise(const CostAddition& cost_addition);

        // adds given linear_constraint for piecewise to the generated qp.
        void addLinearConstraintForPiecewise(const LinearConstraint& linear_constraint);

        // adds given cost_addition for a piece to the generated qp.
        void addCostAdditionForPiece(std::size_t piece_idx,
                                     const CostAddition& cost_addition);

        // adds given linear_constraint for a piece to the generated qp.
        void addLinearConstraintForPiece(std::size_t piece_idx,
                                         const LinearConstraint& linear_constraint);

    private:
        std::unique_ptr<PiecewiseBezierMPCQPOperations> piecewise_operations_ptr_;

        // quadratic program generated by this generator
        qpcpp::Problem<T> problem_;

        // [piece-idx][decision-variable-idx] => Variable<T>*
        std::vector<std::vector<qpcpp::Variable<T>*>> variable_map_;
        // all variables for the piecewise curve
        std::vector<qpcpp::Variable<T>*> variables_;
    };

} // mpc

#endif //MPC_PIECEWISEBEZIERMPCQPGENERATOR_H
