//
// Created by lishuo on 8/22/24.
//

#ifndef MPC_PIECEWISEBEZIERMPCQPGENERATOR_H
#define MPC_PIECEWISEBEZIERMPCQPGENERATOR_H

#include <mpc/optimization/PiecewiseBezierMPCQPOperations.h>
#include <splines/curves/SingleParameterPiecewiseCurve.h>

namespace mpc {

template <typename T, unsigned int DIM>
class PiecewiseBezierMPCQPGenerator {
  public:
    using PiecewiseBezierMPCQPOperations = mpc::PiecewiseBezierMPCQPOperations<T, DIM>;
    using PieceIndexAndParameter =
        typename mpc::PiecewiseBezierMPCQPOperations<T, DIM>::PieceIndexAndParameter;
    using BezierQPOperations =
        typename mpc::PiecewiseBezierMPCQPOperations<T, DIM>::BezierQPOperations;
    using SingleParameterPiecewiseCurve = splines::SingleParameterPiecewiseCurve<T, DIM>;
    using SingleParameterCurve = splines::SingleParameterCurve<T, DIM>;
    using CostAddition = typename mpc::PiecewiseBezierMPCQPOperations<T, DIM>::CostAddition;
    using LinearConstraint = typename mpc::PiecewiseBezierMPCQPOperations<T, DIM>::LinearConstraint;
    using State = model::State<T, DIM>;
    using VectorDIM = math::VectorDIM<T, DIM>;
    using Vector = math::Vector<T>;
    using AlignedBox = math::AlignedBox<T, DIM>;
    using Hyperplane = math::Hyperplane<T, DIM>;

    void addPiecewise(std::unique_ptr<PiecewiseBezierMPCQPOperations>&& piecewise_operations_ptr);
    size_t numPieces() const;
    const std::unique_ptr<PiecewiseBezierMPCQPOperations>& piecewise_operations_ptr() const;

    // return a reference to the problem instance generated by this generator
    qpcpp::Problem<T>& problem();

    std::vector<qpcpp::Variable<T>*>& variables();
    // generates the piecewise curve from the solution to the problem(). it is
    // assumed that variables of the problem() instance is filled by a solver
    // before a call to this function
    SingleParameterPiecewiseCurve generateCurveFromSolution() const;

    Vector getVariablesValue() const;

    // mpc cost, for piecewise
    void addPositionErrorPenaltyCost(const State& current_state, const Vector& ref_positions);
    void addEvalPositionErrorPenaltyCost(const Vector& ref_positions);
    void addControlEffortPenaltyCost();
    // add
    // lambda*\int_{0}^{max_parameter}||df^{derivative_degree}(t)/dt^{derivative_degree}||^2dt
    // cost to the generated problem
    void addIntegratedSquaredDerivativeCost(uint64_t derivative_degree, T lambda);

    // piecewise constraints
    void addEvalBoundConstraints(uint64_t derivative_degree, const VectorDIM& LB,
                                 const VectorDIM& UB);

    // piece cost

    // constraints
    // add df^{derivative_degree}/dt^{derivative_degree}(paramter) = target
    // constraint to the generated qp
    void addEvalConstraint(T parameter, uint64_t derivative_degree, const VectorDIM& target);

    // adds a continuity constraint between pieces with indices piece_idx and
    // piece_idx + 1 on the derivative_degree^th derivative. return status is
    // not ok if piece_idx or piece_idx+1 is out of range
    void addContinuityConstraint(std::size_t piece_idx, uint64_t derivative_degree);

    // constraints the given piece to be in the negative side of the given
    // hyperplane
    void addHyperplaneConstraintForPiece(std::size_t piece_idx, const Hyperplane& hyperplane,
                                         T epsilon = 1e-8);

    // constraint the derivative of the curve within a bounding box
    void addBoundingBoxConstraintAll(const AlignedBox& bounding_box, uint64_t derivative_degree);

    // constraint the trajectory at the given parameter to be in the negative
    // side of the given hyperplane
    void addHyperplaneConstraintAt(T parameter, const Hyperplane& hyperplane, T epsilon = 1e-8);

    // adds given cost_addition for piecewise to the generated qp.
    void addCostAdditionForPiecewise(const CostAddition& cost_addition);

    // adds given linear_constraint for piecewise to the generated qp.
    void addLinearConstraintForPiecewise(const LinearConstraint& linear_constraint);

    // adds given cost_addition for a piece to the generated qp.
    void addCostAdditionForPiece(std::size_t piece_idx, const CostAddition& cost_addition);

    // adds given linear_constraint for a piece to the generated qp.
    void addLinearConstraintForPiece(std::size_t piece_idx,
                                     const LinearConstraint& linear_constraint);

  private:
    std::unique_ptr<PiecewiseBezierMPCQPOperations> piecewise_operations_ptr_;

    // quadratic program generated by this generator
    qpcpp::Problem<T> problem_;

    // [piece-idx][decision-variable-idx] => Variable<T>*
    std::vector<std::vector<qpcpp::Variable<T>*>> variable_map_;
    // all variables for the piecewise curve
    std::vector<qpcpp::Variable<T>*> variables_;
};

} // namespace mpc

#endif //MPC_PIECEWISEBEZIERMPCQPGENERATOR_H
